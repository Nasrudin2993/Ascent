#Ascent - CS50 Final Project#

*By Jamie McKane*

Ascent is a 2D vertical platformer game built in the LÃ¶VE game engine using Lua.

The game is built from scratch, although the structure of some mechanics - such as generating quads from spritesheets, storing behaviour functions in tables, and setting up animations - are adapted from the basic concepts illustrated in the source code for the Mario problem set.

Unlike Mario, this project does not rely on the push and class libraries, as I have opted for a fixed windowed resolution and the manual implementation of OOP using metatables instead.

All sprites, music, sound effects, and other assets were created by me, and the font was sourced from dafont.com.

###Gameplay###

The player spawns at the bottom of the level, with the goal of reaching the top and increasing their score along the way by killing enemies and pickup up gems.

The player can move from side to side, jump, double-jump, attack, and fall through collidable ledges using keybinds which are shown at the beginning of the first level.

The player collides only with the top of the ledges in the level, and only when they are travelling downwards, allowing the player to jump up onto ledges from below.

By holding the drop key - 's' - the player can disable collision and fall through ledges, allowing them to easily access ledges below.

When the player touches the portal at the top of the level, they can press 'Enter' to spawn in a new level with more difficult enemies and greater rewards.

The player's health resets to 100 at the beginning of every level.

These levels are randomly-generated, as are the placement of enemies and gems.

###Random Generation###

The map for each level is randomly generated and takes two arguments for its initilisation function - difficulty and score.

The first initilisation uses score and difficulty values of 0 and 1 respectively. The difficulty modifier increases with each subsequent level, and the score is carried over until the player dies.

The initilisation function for the Map class randomly generates a new map every time it is called.

The random generation algorithm iterates downwards through every row in the tilemap (a two-dimensional array stores the value for every tile), first determining whether to place a ledge and then determining the length of that ledge according to the random seed used for generation.

When a ledge is generated, the function then randomly determines whether to place a gem pickup or a robot on the ledge (or both), the chance of which increases according to the difficulty modifier.

At either end of this randomly-generated map, the algorithm generates a preset start area and end area.

As the algorithm could potentially generate segments of the tileset which are intraversible by the player (i,e. there are no ledges to jump to), a check is included which ensures that if no ledge is generated after a certain number of iterations, a ledge is generated anyway to ensure the map is playable.

Robots which are generated over the course of this algorithm are stored in a table within the map object.

###Enemy objects and AI###

Each robot enemy generated by the random generation algorithm is its own object, inheriting its initiliastion function through a call to the Robot class by the Robot_mt metatable.

This allows each enemy to have its own health pool, movement, and player detection functions.

When a robot is initiated, it begins patrolling its ledge, changing direction when it detects it has reached the edge of the platform.

When the player enters its vicinity, the robot changes to an attacking state and begins attacking the player after a short delay. This delay is observed between each attack, and it as well as the damage the robot does to the player and the robot's health are also affected by difficulty modifier.

This means that while the robots on level 1 are relatively easy to kill and slow to react when the player nears them, they quickly become more deadly as the player progresses.

The player can also earn score for killing robots, and the score they provide upon death increases with the difficulty of the level.

###Animations and sound###

Ascent features a number of sprite-based animations. There are separate spritesheets for the level, the robot enemies, and the player.

The player has a walking, jumping, attacking, idle, and death animation; the robots have a walking, attacking, and death animation; and both the portals and gem pickups on the map are animated.

Sound effects apply to a variety of events, and were created with the free Bfxr software used in the Mario problem set.

I wrote the background music using a MIDI controller and a free DAW program named Waveform.

The game also features a basic text-based user interface which shows the character's health, score, and the current level.
